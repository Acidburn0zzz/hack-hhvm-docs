<?xml version="1.0" encoding="utf-8"?>
<chapter xml:id="hack.customattributes">
  <title>Custom Attributes</title>
  <para>
    Attributes in Hack provide the ability to give the Hack type checker and
    HHVM runtime additional, contextual information about a class, method,
    property or function. Attributes are declarative tags of the form <literal
    >&lt;&lt;__AttributeName&gt;&gt;</literal>, placed above the signature of
    the code on which the attribute is to be applied. For example:
    <informalexample>
      <programlisting role="php">
<![CDATA[
<?hh
class Foo {
  <<__Memoize>>
  public function bar(string $key) {
    return baz($key);
  }
}
]]>
      </programlisting>
      <para>
        The &lt;&lt;__Memoize&gt;&gt; attribute above <literal>bar()</literal>
        tells the HHVM runtime to cache the result of the call to <literal>baz()
        </literal>.
      </para>
    </informalexample>
  </para>
  <para>
    Multiple attributes can even be applied to a piece of code. The form is
    <literal>&lt;&lt;__Attribute1, __Attribute2&gt;&gt;</literal>.
  </para>
  <note>
    <para>
      Note that, currently, Hack custom attributes are prefixed with <literal>__
      </literal>. This is to signify that the custom attribute has meaning to
      the HHVM compiler rather than just user space decoration. It is analogous
      to the underscores on <literal>__call()</literal> hinting that
      it is special.
    </para>
  </note>
  <sect1 xml:id="hack.customattributes.override">
    <title>__Override Attribute</title>
    <para>
      The <literal>__Override</literal> attribute is the child class' counterpart
      to the parent class' <literal>abstract</literal> declaration. It is an
      optional annotation on a method, implemented with the
      <literal>&lt;&lt;__Override&gt;&gt;</literal> user attribute. If the
      <literal>&lt;&lt;__Override&gt;&gt;</literal> attribute is found on a
      method, and that method does not exist in the set of (non-interface)
      methods inherited from parents, an error is thrown. In Hack partial mode,
      this has the effect of throwing when the parent is defined in PHP, since
      the type checker cannot access the parent's method declarations.
      Consider the following:
      <informalexample>
        <programlisting role="php">
<![CDATA[
// file1.php
<?hh

class CParent {
  public function doStuff(): void {
    return $this->implementation();
  }
  protected function implementation(): void {
    echo 'parent implementation', "\n";
  }
}

// file2.php
<?hh
class Child extends CParent {
  <<__Override>>
  protected function implementation(): void {
    echo 'child implementation', "\n";
  }
}
]]>
        </programlisting>
        <para>
          If the parent class is (inadvertently) refactored to the following...
        </para>
        <programlisting role="php">
<![CDATA[  // file1.php
<?hh
class CParent {
  public function doStuff(): void {
    echo 'parent implementation', "\n";
  }
}
]]>
        </programlisting>
        <para>
        ... the <literal>&lt;&lt;__Override&gt;&gt;</literal> annotation will
        result in a type checker error, alerting the refactorer of
        <literal>CParent</literal> of the existence of <literal>Child</literal>.
        </para>
      </informalexample>
    </para>
    <sect2 xml:id="hack.customeattributes.override.traits">
      <title>In Traits</title>
      <para>
        The <literal>&lt;&lt;__Override&gt;&gt;</literal> annotation may also be
        added to trait methods, although with slightly different behavior than
        in standard classes. For trait methods annotated with
        <literal>&lt;&lt;__Override&gt;&gt;</literal>, the check of whether the
        overridden method exists is deferred to the classes that
        <literal>use</literal> the trait.
        <informalexample>
          <programlisting role="php">
<![CDATA[
<?hh
trait T1 {
  <<__Override>> // checked on use classes
  function foo(): void {}
}

class C1 {
  use T1; // error! foo is not an override
}

class C2 {
  function foo(): void {}
}

class C3 extends C2 {
  use T1; // OK! C2's implementation is being overridden
}
]]>
          </programlisting>
        </informalexample>
      </para>
    </sect2>
  </sect1>
  <sect1 xml:id="hack.customattributes.memoize">
    <title>__Memoize Attribute</title>
    <para>
      As of HHVM 3.3, the <literal>__Memoize</literal> attribute allows
      functions to cache their results, without having to explicitly define
      custom caching mechanisms. An example is the best way to illustrate
      <literal>__Memoize</literal>. Formerly, caching was done in this sort of
      manner:
      <informalexample>
        <programlisting role="php">
<![CDATA[
<?hh
class Baz {}
class Foo {
  private Map $cache;

  public function bar(string $key): Baz {
    if (!isset($this->cache[$key])) {
      $this->cache[$key] = function_that_returns_baz($key);
    }
    return $this->cache[$key];
  }
}
]]>
        </programlisting>
        <para>
          This code employs an explicit caching mechanism to avoid possibly
          expensive function calls.
        </para>
      </informalexample>
    </para>
    <para>
      Now see how much simpler and succinct <literal>__Memoize</literal> makes
      the code above:
      <informalexample>
        <programlisting role="php">
<![CDATA[
<?hh
class Baz {}
class Foo {
  <<__Memoize>>
  public function bar(string $key): Baz {
    return function_that_returns_baz($key);
  }
}
]]>
        </programlisting>
        <para>
          After the first call to <literal>bar()</literal>, the result will be
          automatically cached so that subsequent calls to
          <literal>bar()</literal> will not result in a potentially expensive
          call to <literal>function_that_returns_baz()</literal>.
        </para>
      </informalexample>
    </para>
    <para>
      <literal>__Memoize</literal> can be used on any type of function (e.g.
      <literal><link linkend="hack.async">async</link></literal>, <literal>
      static</literal>, <literal>top-level</literal>, etc.), with any
      number of arguments. The limitations are:
      <simplelist>
        <member>The arguments must be explicit (i.e., no varargs).</member>
        <member>The arguments cannot be passed by reference.</member>
        <member>The supported argument types are <literal>null</literal>,
        <literal>bool</literal>, <literal>int</literal>,
        <literal>float</literal>, <literal>string</literal>, any object
        implementing the <literal>IMemoizeParam</literal> interface, and arrays/
        collections containing any supported argument type.</member>
      </simplelist>
    </para>
    <note>
      <para>
        <literal>__Memoize</literal> applies to the specific function on which
        it is applied. It is not applied to other named functions in its class
        hierarchy. Here is an example:
        <informalexample>
          <programlisting role="php">
<![CDATA[
<?hh
class Baz {}
class Parent {
  // Memozing will *not* occur on this function
  public function foo(string $key): Baz {
    return function_that_returns_baz($key);
  }
}
class Child extends Parent {
  <<__Override, __Memoize>>
  public function foo(string $key): Baz {
    return another_function_that_returns_baz($key);
  }
}
]]>
          </programlisting>
        </informalexample>
      </para>
    </note>
    <warning>
      <para>
        Do not abuse the use of <literal>__Memoize</literal>. It might be tempting
        to memoize everything, but remember that the cost of memoizing is
        increased memory usage. Proper use of <literal>__Memoize</literal>,
        though, can possibly increase performance with a minimal increase in
        memory overhead. A good rule of thumb is that if you wouldn't take the
        time to write caching code manually if <literal>__Memoize</literal>
        didn't exist, then don't use <literal>__Memoize</literal>.
      </para>
    </warning>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
