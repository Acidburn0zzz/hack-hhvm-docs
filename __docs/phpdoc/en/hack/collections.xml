<?xml version="1.0" encoding="utf-8"?>
<chapter xml:id="hack.collections">
  <title>Collections</title>
  <para>
    The PHP language provides one primary mechanism for expressing containers of elements: the PHP array. Traditionally, the term &quot;array&quot; in programming languages is thought of as a collection of elements, indexed using consecutive integers (starting at 0 or 1), and possibly of a fixed size (e.g., Java). PHP arrays are significantly different than the traditional concept of arrays. A PHP array is essentially a dictionary-style collection associating keys with values that maintains insertion order. The keys can be either integers or strings; the values can be of any type. PHP arrays are dynamically-sized and grow as needed without requiring a function call to increase their size/capacity. In all Hack documentation, the term "array" will be considered to refer to a PHP array unless explicitly noted otherwise. Arrays in PHP are created using the <literal>array()</literal> language construct. Here are a few examples:
    <informalexample>
      <programlisting role="php" location="hack.collections1.php" />
      <para>
        Even with the relatively simple examples above, it is easy to see that PHP arrays are different than the &quot;arrays&quot; in other popular programming languages. In addition to offering dictionary-like operations, PHP arrays also offer stack-like operations. For example, values on PHP arrays can be pushed, popped or shifted.
      </para>
    </informalexample>
  </para>
  <para>
    Hack adds container types and interfaces to PHP. Building on Hack's support for generics, Hack adds first class, built-in parameterized collections such as vectors and maps. Collections are specialized for data storage and retrieval. Collections implement many of the same interfaces and are extendable to create even more specialized collections.
  </para>
  <para>
    While arrays are geared towards a "one size fits all" model, Hack collections try to provide more specificity in their usage. Like arrays, the values held in a collection can generally be of any type (e.g., the value of a <literal>Vector</literal> can be a scalar, any PHP object, an array, even another <literal>Vector</literal>).
  </para>
  <note>
    <para>
      In Hack and PHP5, arrays are not objects. Hack collections are typed as objects. So,
            <informalexample>
        <programlisting role="php" location="hack.collections2.php" />
        &example.outputs;
        <screen>
<![CDATA[
bool(false)
bool(true)
]]>
        </screen>
      </informalexample>
    </para>
  </note>
  <para>
  Currently, Hack implements the following concrete collection types:
  </para>
  <itemizedlist>
    <listitem>
      <para>
        <literal><link linkend="class.hack.vectortv">Vector</link></literal>: An ordered, index-based list collection.
      </para>
    </listitem>
    <listitem>
      <para>
        <literal><link linkend="class.hack.immvectortv">ImmVector</link></literal>: An immutable, ordered, index-based list collection.
      </para>
    </listitem>
    <listitem>
      <para>
        <literal><link linkend="class.hack.maptktv">Map</link></literal>: An ordered dictionary-style collection.
      </para>
    </listitem>
    <listitem>
      <para>
        <literal><link linkend="class.hack.immmaptktv">ImmMap</link></literal>: An immutable, ordered dictionary-style collection.
      </para>
    </listitem>
    <listitem>
      <para>
        <literal><link linkend="class.hack.settv">Set</link></literal>: A list-based collection that stores unique values.
      </para>
    </listitem>
    <listitem>
      <para>
        <literal><link linkend="class.hack.immsettv">ImmSet</link></literal>: An immutable, list-based collection that stores unique values.
      </para>
    </listitem>
    <listitem>
      <para>
        <literal><link linkend="class.hack.pairtv1tv2">Pair</link></literal>: An index-based collection that can hold exactly two elements.
      </para>
    </listitem>
  </itemizedlist>
  <note>
    <para>
      All of the above classes are <link linkend="language.oop5.final"><literal>final</literal></link>. You will need to use some sort of composition pattern or define new classes if you want to do something such as add new helper methods.
    </para>
  </note>
  <para>
    The primary interfaces implemented by these collections (except <literal>Pair</literal>) have two incarnations: the normal, read-write interface implemented by the classes above and a read-only interface. The read-write interface is prefixed by <literal>Mutable</literal> and the read-only interface is prefixed by <literal>Const</literal>.
  </para>
  <para>
    Here is an example of using Hack collections:
    <informalexample>
      <programlisting role="php" location="hack.collections3.php" />
      &example.outputs;
      <screen>
<![CDATA[
5
10
20
25
]]>
      </screen>
    </informalexample>
  </para>

  <sect1 xml:id="hack.collections.goals">
    <title>Goals</title>
    <para>
      Given the wide range of functionality offered by PHP arrays, they can be used to mimic common specialized collection types such as vectors, dictionaries, and sets. So why extend HHVM with its own collection classes and functionality? One key reason is code clarity. It's not always clear in PHP how an array is being used, or what the types of the keys and values are. This makes it harder to confidently make changes to a larger codebase without introducing subtle bugs. Another key reason is PHP array performance. Generally speaking, it is impossible to know with certainty if a PHP array is going to be used as a vector, as a map, as a set, etc., and as such the code generated by HHVM and associated data structures are more complex. Also, PHP arrays are copy-on-write. This means that programmers must use PHP references when they don't want the array to be copied, and using PHP references generally degrades code performance. Enter the Hack collection classes.
    </para>
    <para>
      The goals of Hack collections are four-fold:
      <orderedlist>
        <listitem>
          <para>
            Provide a unified collections framework that is simple and intuitive.
          </para>
        </listitem>
        <listitem>
          <para>
            Provide equal or better performance than the equivalent PHP array pattern.
          </para>
        </listitem>
        <listitem>
          <para>
            Provide a collection implementation that allows for optional static typing, integrating seamlessly with Hack.
          </para>
        </listitem>
        <listitem>
          <para>
            Provide an easy migration path to this framework by building on top of standard functionality from PHP5.
          </para>
        </listitem>
      </orderedlist>
    </para>
    <para>
      Like PHP arrays, Hack collections support foreach syntax for enumerating elements, and most collections support bracket syntax (e.g. <literal>$c[$k]</literal>) for accessing elements. Unlike PHP arrays, however, Hack collections are considered to be objects. Like all objects, Hack collections have reference-like semantics for assignment, parameter passing, and foreach. In other words, the collection is not copied when it is assigned to a variable, passed as a parameter, or returned as a return value (i.e., no copy-on-write semantics).
    </para>
    <para>
      Hack collections were designed to work with Hack and integrate with Hack's generics. Generics allow for the parameterization of a type. Why is this useful? It allows for the creation of a collection type that is type-safe at compile time. In other words, instead of assuming one starts with a top-level object and then performs <literal>instanceof</literal> checks and casting at runtime to retrieve the appropriate type, the correct type can be determined at compile time. And while at present Hack collections do not perform type checking on elements at run time (i.e., type information will be dropped at runtime), using generics allows Hack to catch typing errors involving collection elements in near real time. Generics are not available with PHP5.
    </para>
    <para>
      Note that Hack generic type annotations are not strictly required for Hack collections. The Hack collection interfaces and APIs may be used in regular, untyped PHP code. Like all generics in Hack, the generics used with Hack collections will be &quot;erased&quot; (either fully or partially) at run time.
    </para>
  </sect1>


  <sect1 xml:id="hack.collections.vector">
    <title>Vector</title>
    <para>
      A Vector is an integer-indexed (zero-based) collection with similar semantics to a C++ <literal>vector</literal> or a C#/Java <literal>ArrayList</literal>. Random access to elements happen in O(1) time. Inserts occur at O(1) when added to the end, but could hit O(n) with inserts elsewhere. Removal has similar time semantics. Iteration over the entire vector occurs at O(n) time. Inserting n elements into an empty Vector will take O(n) time in the average case (amortized). Here is the <link linkend="class.hack.vectortv">programmer accessible interface</link> of a Hack <literal>Vector</literal>.
    </para>
    <para>
      Here are some basic examples that show how <literal>Vector</literal> can be used:
      <informalexample>
        <programlisting role="php" location="hack.collections4.php" />
        &example.outputs;
        <screen>
<![CDATA[
5
10

999
10
20
25

999
10
20
25

0: 999
1: 10
2: 20
3: 25
]]>
        </screen>
      </informalexample>
      <informalexample>
        <programlisting role="php" location="hack.collections5.php" />
        &example.outputs;
        <screen>
<![CDATA[
0 80

1 60
]]>
        </screen>
      </informalexample>
    </para>
  </sect1>

  <sect1 xml:id="hack.collections.map">
    <title>Map</title>
    <para>
      A Map is an ordered dictionary-style collection. Elements are stored as key/value pairs. <emphasis>Maps retain element insertion order</emphasis>, meaning that iterating over a Map will visit the elements in the same order that they were inserted. Insert, remove and search operations are performed in O(lg n) time or better (amortized). <emphasis>Note: <literal>Map</literal> only supports <literal>int</literal> and <literal>string</literal> keys at present. Support for other types may come in the future.</emphasis> Here is the <link linkend="class.hack.maptktv">programmer accessible interface</link> for <literal>Map</literal>.
    </para>
    <para>
      Here are some basic examples showing how <literal>Map</literal> can be used:
      <informalexample>
        <programlisting role="php" location="hack.collections6.php" />
        &example.outputs;
        <screen>
<![CDATA[
1
2

true

1
3
4
5

A: 1
C: 3
D: 4
E: 5
]]>
        </screen>
      </informalexample>
            <informalexample>
        <programlisting role="php" location="hack.collections7.php" />
        &example.outputs;
        <screen>
<![CDATA[
object(Map)#1 (2) {
  [3]=>
  string(1) "c"
  [4]=>
  string(1) "d"
}
]]>
        </screen>
      </informalexample>
    </para>
  </sect1>

<sect1 xml:id="hack.collections.set">
    <title>Set</title>
    <para>
      A Set is an ordered collection that stores unique values. Unlike vectors and maps, sets do not have keys, and thus cannot be iterated on keys (i.e., <literal>Set</literal> does not implement <literal>KeyedIterable</literal>). Likewise, sets do not support <literal>$c[$k]</literal> or <literal>$c[$k]=$v</literal> syntax (though <literal>$c[]=$v</literal> syntax is supported for adding elements). Insert, remove, and search operations for <literal>Set</literal> are performed in O(lg n) time or better. Intersect and some other operations are available in the Sets class. <emphasis>Note: <literal>Set</literal> only supports <literal>int</literal> and <literal>string</literal> values at present. Support for other types may come in the future.</emphasis> Here is the <link linkend="class.hack.settv">programmer accessible interface</link> of a Hack implemented <literal>Set</literal>.
    </para>
    <para>
      Here is a basic example showing how <literal>Set</literal> can be used:
            <informalexample>
        <programlisting role="php" location="hack.collections8.php" />
        &example.outputs;
        <screen>
<![CDATA[
true

A
C
D
E
]]>
        </screen>
      </informalexample>
    </para>
    <para>
      Here is an example of taking the difference between two sets using <literal>removeAll</literal>
      <informalexample>
        <programlisting role="php" location="hack.collections9.php" />
        &example.outputs;
        <screen>
<![CDATA[
object(Set)#1 (2) {
  int(4)
  int(6)
}
object(Set)#2 (3) {
  int(2)
  int(3)
  int(5)
}
object(Set)#1 (2) {
  int(4)
  int(6)
}
]]>
        </screen>
      </informalexample>
    </para>
  </sect1>

  <sect1 xml:id="hack.collections.pair">
    <title>Pair</title>
    <para>
      A Pair is an indexed container restricted to containing exactly two elements. <literal>Pair</literal> has integer keys; key 0 refers to the first element and key 1 refers to the second element (all other integer keys are out of bounds). The first type parameter specifies the type constraint for the first element, and the second type parameter specifies the type constraint for the second element. <literal>Pair</literal>s are immutable, meaning that the elements of a <literal>Pair</literal> cannot be assigned to or removed. Note however that <literal>Pair</literal>s may contain mutable objects. <emphasis>In many cases, a <link linkend="hack.tuples">tuple</link> is a better choice than a Pair.</emphasis> Here is the <link linkend="class.hack.pairtv1tv2">programmer accessible interface</link> for Hack pairs.
    </para>
    <para>
      Here is a simple example showing how <literal>Pair</literal> can be used:
      <informalexample>
        <programlisting role="php" location="hack.collections10.php" />
        &example.outputs;
        <screen>
<![CDATA[
7
a

7
a
]]>
        </screen>
      </informalexample>
    </para>
  </sect1>

<sect1 xml:id="hack.collections.immutable">
  <title>Immutable Collections</title>
  <para>
    Collections in Hack can take on two primary forms: mutable and immutable. The mutable <literal>Vector</literal>, <literal>Map</literal>, and <literal>Set</literal> all have immutable counterparts. The immutable collections are, as you would imagine, constant. No elements can be added or removed from them. Likewise, elements cannot be overridden using assignment.
  </para>
  <para>
    Immutable collections generally implement a ConstXYZ interface (e.g., <literal><link linkend="class.hack.constvectortv">ConstVector</link></literal>). Here are the current concrete immutable collection classes:
    <itemizedlist>
      <listitem><para><link linkend="class.hack.immvectortv"><literal>ImmVector</literal></link></para></listitem>
      <listitem><para><link linkend="class.hack.immmaptktv"><literal>ImmMap</literal></link></para></listitem>
      <listitem><para><link linkend="class.hack.immsettv"><literal>ImmSet</literal></link></para></listitem>
    </itemizedlist>
  </para>
</sect1>

 <sect1 xml:id="hack.collections.interfaces">
    <title>Collection Interfaces</title>
    <para>
      The following diagram shows at a high level how Hack collection interfaces are structured.
      <figure>
        <title>Collections Implementation</title>
        <mediaobject>
          <alt>Collection implementation diagram</alt>
          <imageobject>
            <imagedata fileref="en/hack/figures/collectionsimpl.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </para>
    <para>
      In the design of HipHop collections, these general design patterns were followed:
      <orderedlist>
        <listitem>
          <para>
            Used patterns that PHP developers are accustomed to within various codebases (e.g., <literal>foreach</literal> both key/value and just value iteration).
          </para>
        </listitem>
        <listitem>
          <para>
            Allowed use of <literal>foreach</literal>, brackets syntax (e.g., <literal>$a[$b]</literal>) and higher order functions (e.g., <literal>filter</literal>) instead of manually operating on iterators.
          </para>
        </listitem>
        <listitem>
          <para>
            Allowed for supporting covariance and contravariance in the future to provide maximum power and flexibility while maintaining type safety.
          </para>
        </listitem>
        <listitem>
          <para>
            Followed design patterns from other popular collections frameworks where appropriate (e.g, C++, C#, Java, Python, Scala) for maximum developer appeal.
          </para>
        </listitem>
      </orderedlist>
    </para>
    <para>
      <emphasis>Potential</emphasis> support for covariance and contravariance is indicated by the &quot;out&quot; keyword and &quot;in&quot; keyword respectively , though at present Hack does not support &quot;out&quot; and &quot;in&quot;.
    </para>
    <sect2 xml:id="hack.collections.interfaces.specific">
      <title>Specific Collection Interfaces</title>
      <para>
        The concrete collection classes (<literal>Vector</literal>, <literal>Map</literal>, etc.) use the collection interfaces as building blocks. Before diving into the lower layers of interfaces, it's worth covering the specific collection interfaces first.
      </para>
      <para>
        The "const" interfaces (<link linkend="class.hack.constvectortv"><literal>ConstVector</literal></link>, <link linkend="class.hack.constmaptktv"><literal>ConstMap</literal></link>, and <link linkend="class.hack.constsettv"><literal>ConstSet</literal></link>) can be used in parameter type constraints to indicate that a given function will not mutate the collection. This can be important for larger codebases since collections have "reference-like"semantics and do not have "copy-on-write" behavior like PHP arrays. The "const" interfaces also provides a good foundation for adding "immutable" versions of collections (<literal>ImmVector</literal>, <literal>ImmMap</literal>, etc.) and for potentially supporting covariance in the future. The <literal>ConstMap</literal> interface can be used in a parameter type constraint to indicate that a given function will accept both Maps and ImmMaps. The collection specific interfaces also lay the foundation for adding more types of collections or user-defined collections down the road. Each of the "const" interfaces has a "mutable" counterpart (e.g. <link linkend="class.hack.mutablevectortv">MutableVector</link>)
      </para>
    </sect2>
    <sect2 xml:id="hack.collections.interfaces.iteration">
      <title>Iteration Interfaces</title>
      <para>
        The <literal>Iterable</literal>, <literal>Traversable</literal>, and associated interfaces allow for the traversal of values or keys/values coming from some source, whether it be a collection or a generator or some other kind of object.
      </para>
      <para>
        The <literal>Traversable</literal> style interfaces provide a continuous feeding of elements with <literal>foreach</literal>. <literal>Traversable</literal> also provides the capability for code to be compatible with both arrays and collections, while allowing for the typing of keys and values. A function that takes an <literal>Indexish</literal>, for example, can be passed an <literal>array&lt;int&gt;</literal> or a <literal>Vector&lt;int&gt;</literal>.
      </para>
      <para>
        <literal>Indexish</literal> is another interface that works with both arrays and collections, and it is intended to help ease the migration from arrays to typed collections for certain use cases. <literal>Indexish</literal> supports the array-like, square bracket (e.g. <literal>$x[$k]</literal>) syntax while also supporting the iteration via <literal>foreach</literal> (by extending the <literal>Traversable</literal> interface). The <literal>Indexish</literal> interface does not include functionality for mutating the underlying array or collection; this includes appending, removing, changing element types and changing the values of elements. While the <literal>Indexish</literal> does offer functionality for mutation, it is still possible to mutate the underlying array or collection if the programmer uses <literal>is_array()</literal> or <literal>instanceof</literal> to cast the container to its concrete type, or if the container is passed to "untyped" code. It is important to note that the copy semantics do remain the same for arrays and collections when using <literal>Indexish</literal>. Arrays are still copy-on-write, while collections are passed by reference.
      </para>
      <para>
        Given that <literal>Indexish</literal> supports keyed collections, <literal>Vector</literal> and <literal>Map</literal> implement <literal>Indexish</literal>. <literal>Set</literal> (which doesn't have a key) and <literal>Pair</literal> do not.
      </para>
      <para>
        The <literal>Iterable</literal> style interfaces allow for retrieving values using <literal>foreach</literal> at chosen times through the use of iterators (e.g.. <literal>next</literal>), while also providing various helper functions that can be used during iteration.
      </para>
    </sect2>
    <sect2 xml:id="hack.collections.interfaces.general">
      <title>General Collection Interfaces</title>
      <para>
        The <literal>Collection</literal> interface provides basic functionality for adding and erasing elements, as well as iterating over elements in a uniform manner.
      </para>
    </sect2>
    <sect2 xml:id="hack.collections.interfaces.access">
      <title>Access Interfaces</title>
      <para>
        Depending on the type of collection type implemented, one of the following interfaces (<literal>IndexAccess</literal>, <literal>SetAccess</literal> or <literal>MapAccess</literal>) will be implemented. These interfaces provide the functionality for checking values in a collection by index/key, removing items from a collection by index/key, as well as providing <literal>[]</literal> syntax for accessing values by index/key. All three of these interface types have a "const" companion for cases where the programmer wants to enforce a "read-only" contract.
      </para>
    </sect2>
  </sect1>

  <sect1 xml:id="hack.collections.squarebracketsyntax">
    <title>Square Bracket Syntax</title>
    <para>
      The Hack collection classes provides two primary mechanisms for accessing elements: square bracket syntax (e.g. <literal>[]</literal>) and explicit <literal>get</literal>/<literal>set</literal> methods. Both are obviously completely valid for use. However, it is recommended that square bracket syntax be used. Square bracket syntax should be familiar to PHP developers via arrays, as well as developers in other languages like C#. <literal>[]</literal> is the preferred for several reasons:
      <itemizedlist>
        <listitem>
          <para>
            It is currently faster to use at runtime.
          </para>
        </listitem>
        <listitem>
          <para>
            It is more readable to people who read PHP code since <literal>[]</literal> is used with arrays.
          </para>
        </listitem>
        <listitem>
          <para>
            Code that is required to support both collections and arrays will require <literal>[]</literal>, along with the <literal>KeyedTraversable</literal> and/or <literal>Indexish</literal>interfaces, to be interoperable.
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </sect1>

  <sect1 xml:id="hack.collections.literalsyntax">
    <title>Literal Syntax</title>
    <para>
      Hack collections has introduced a literal syntax in order to make it easy to create a new collection without the need for temporary arrays or helper functions. HHVM natively understands collection literals. Here is an example:
      <informalexample>
        <programlisting role="php" location="hack.collections11.php" />
        <para>
            The code above requires no hidden arrays or helper functions to build a Vector containing 1, 2, and 3.
        </para>
      </informalexample>
    </para>
    <para>
      Here are some basic examples showing how collection literal syntax can be used:
      <informalexample>
        <programlisting role="php" location="hack.collections12.php" />
        &example.outputs;
        <screen>
  <![CDATA[
object(Vector)#1 (3) {
  [0]=>
  int(1)
  [1]=>
  int(2)
  [2]=>
  int(3)
}
object(Map)#1 (3) {
  [42]=>
  string(3) "foo"
  [73]=>
  string(3) "bar"
  [144]=>
  string(3) "baz"
}
  ]]>
        </screen>
      </informalexample>
      <informalexample>
        <programlisting role="php" location="hack.collections13.php" />
      </informalexample>
    </para>
    <para>
      There are several reasons why this mechanism of literal syntax was chosen over other candidates (e.g., Python-style or using parenthesis instead of curly braces):
      <itemizedlist>
        <listitem>
          <para>
            &quot;<literal>[..]</literal>&quot; syntax has already been taken by PHP 5.4 for 'short array syntax'. </para>
        </listitem>
        <listitem>
          <para>
            The current collection literal syntax is clearly distinct from function call syntax, which makes it easier for HipHop to treat it differently than a function call and deliver performance that is competitive with PHP arrays. This also means that new keywords don't need to be added or the HipHop runtime hacked to allow &quot;=>&quot; inside <literal>map(..)</literal> but not inside other function calls.
          </para>
        </listitem>
        <listitem>
          <para>
            This literal syntax scales better for adding future built-in collection types. This syntax also leaves the possibility open for allowing some user-defined classes to use this syntax down the road.
          </para>
        </listitem>
        <listitem>
          <para>
            It leaves the possibility open for specifying the extended type of a collection (e.g.,. <literal>Vector&lt;Foo&gt; {f(), g()}</literal>), which may come in handy for some use cases, and it may be useful down the road when generics are integrated into HipHop's type system.
          </para>
        </listitem>
        <listitem>
          <para>
            This literal syntax is reasonably concise when compared with the classic array literal syntax (e.g., <literal>array(..)</literal>), and it doesn't preclude the possibility of having a more concise syntax in the future for vectors and maps.
          </para>
        </listitem>
        <listitem>
          <para>
            This syntax has similarities with various initialization constructs in several popular languages that are syntactically similar to PHP (ex. C, C++, Java, C#), giving it a familiar feel for PHP developers.
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </sect1>

  <sect1 xml:id="hack.collections.phpoperators">
    <title>Basic PHP operators and Collections</title>
    <para>
      For the most part, collections behave like regular PHP objects, though there are some places where collections behave differently than regular PHP objects:
      <itemizedlist>
        <listitem>
          <para>
            list assignment with a collection on the right hand side works as you would expect.
          </para>
        </listitem>
        <listitem>
          <para>
            Comparing collections using <literal>===</literal> returns true if and only if they are the same object (reference equality).
          </para>
        </listitem>
        <listitem>
          <para>
            Comparing collections using <literal>==</literal> will compare collections for &quot;structural equality&quot;. <literal>==</literal> will always return <literal>false</literal> if dealing with different kinds of collections. <literal>==</literal> takes order into account for <literal>Vector</literal> and <literal>Pair</literal>, but does not care about order for <literal>Map</literal> and <literal>Set</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            Casting a collection to array (<literal>(array)$c</literal>) will produce an array containing the keys and values from the collection (same as <literal>$c->toArray()</literal>). </para>
        </listitem>
        <listitem>
          <para>
            Casting a collection to boolean (<literal>(bool)$c</literal>) will produce true if the collection is non-empty, false otherwise (same as <literal>!$c->isEmpty()</literal>).
          </para>
        </listitem>
        <listitem>
          <para>
            Other kinds of casts behave the same way for collections as they do for regular PHP objects.
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </sect1>

  <sect1 xml:id="hack.collections.phpbuiltins">
    <title>PHP Builtin Support</title>
    <para>
      In large PHP codebases, data flow can be very complex, and so it's important to make collections work together with common PHP builtins so that migration is as easy as possible. Below is a summary of what PHP builtin functions currently work with collections:
      <itemizedlist>
        <listitem>
          <para>
            <literal>apc_store(string,mixed,int)</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array_combine()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array_diff()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array_diff_key()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array_filter()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array_intersect()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array_intersect_key()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array_keys()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array_map()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array_push()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array_values()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>count()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>debug_zval_dump()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>implode()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>join()</literal> (alias of <literal>implode()</literal>)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>print_r()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>serialize()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>sizeof()</literal> (alias for <literal>count()</literal>)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>unserialize()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>var_dump()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>var_export()</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array_key_exists()</literal> - for <literal>Vector</literal> and <literal>Map</literal> only
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>idx()</literal> - for <literal>Vector</literal> and <literal>Map</literal> only
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>sort()</literal> - for <literal>Vector</literal> only
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>rsort()</literal> - for <literal>Vector</literal> only
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>usort()</literal> - for <literal>Vector</literal> only
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>arsort()</literal> - for <literal>Map</literal> only
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>uasort()</literal> - for <literal>Map</literal> only
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>ksort()</literal> - for <literal>Map</literal> only
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>krsort()</literal> - for <literal>Map</literal> only
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>uksort()</literal> - for <literal>Map</literal> only
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>natsort()</literal> - for <literal>Map</literal> only
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>natcasesort()</literal> - for <literal>Map</literal> only
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      At present, most other standard PHP builtins that accept arrays as parameters either (1) do not support collections or (2) silently copy the collection to an array.
    </para>
  </sect1>

  <sect1 xml:id="hack.collections.examples">
    <title>Examples</title>
    <para>
      Here are some more examples that showcase much of the functionality of the Hack collection interfaces and classes.
    </para>
    <sect2 xml:id="hack.collections.examples.collectionsareobjects">
      <title>Collections are objects</title>
            <informalexample>
        <programlisting role="php" location="hack.collections14.php" />
        &example.outputs;
        <screen>
<![CDATA[
$v is not an array
$v is an object
object(Vector)#1 (3) {
  [0]=>
  int(1)
  [1]=>
  int(2)
  [2]=>
  int(3)
}
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.referencesemantics">
      <title>Reference-like Semantics</title>
      <informalexample>
        <programlisting role="php" location="hack.collections15.php" />
        &example.outputs;
        <screen>
<![CDATA[
object(Vector)#1 (3) {
  [0]=>
  int(1)
  [1]=>
  int(7)
  [2]=>
  int(3)
}

0 => 1
1 => 7
2 => 9
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.iterator">
      <title>Iterator Invalidation</title>
      <informalexample>
        <programlisting role="php" location="hack.collections16.php" />
        &example.outputs;
        <screen>
<![CDATA[
a => 1
HipHop Fatal error: Uncaught exception 'InvalidOperationException' with message 'Collection was modified during iteration'
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.keynotpresent">
      <title>Key Not Present</title>
      <informalexample>
        <programlisting role="php" location="hack.collections17.php" />
        &example.outputs;
        <screen>
<![CDATA[
Caught exception 1
Caught exception 2
NULL
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.const">
      <title>Const Interfaces</title>
            <informalexample>
        <programlisting role="php" location="hack.collections18.php" />
        &example.outputs;
        <screen>
<![CDATA[
3
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.keys">
      <title><literal>keys()</literal> method</title>
      <informalexample>
        <programlisting role="php" location="hack.collections19.php" />
        &example.outputs;
        <screen>
<![CDATA[
object(Vector)#2 (4) {
  [0]=>
  string(1) "a"
  [1]=>
  string(1) "b"
  [2]=>
  string(1) "c"
  [3]=>
  string(1) "d"
}
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.mapmethod">
      <title><literal>map()</literal> method</title>
      <informalexample>
        <programlisting role="php" location="hack.collections20.php" />
        &example.outputs;
        <screen>
<![CDATA[
object(Map)#2 (4) {
  ["a"]=>
  int(11)
  ["b"]=>
  int(12)
  ["c"]=>
  int(13)
  ["d"]=>
  int(14)
}
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.filter">
      <title><literal>filter()</literal> method</title>
      <informalexample>
        <programlisting role="php" location="hack.collections21.php" />
        &example.outputs;
        <screen>
<![CDATA[
object(Map)#2 (2) {
  ["b"]=>
  int(2)
  ["d"]=>
  int(4)
}
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.iterables">
      <title>Iterables</title>
      <informalexample>
        <programlisting role="php" location="hack.collections22.php" />
        &example.outputs;
        <screen>
<![CDATA[
b => 3
d => 5
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.lazyviews">
      <title>Lazy Views</title>
      <informalexample>
        <programlisting role="php" location="hack.collections23.php" />
        &example.outputs;
        <screen>
<![CDATA[
a => 100
b => 2
c => 3
Removing key 'a'
HipHop Fatal error: Uncaught exception 'InvalidOperationException' with message 'Collection was modified during iteration'
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.vector">
      <title><literal>Vector</literal></title>
      <informalexample>
        <programlisting role="php" location="hack.collections24.php" />
        &example.outputs;
        <screen>
<![CDATA[
object(Vector)#1 (4) {
  [0]=>
  int(11)
  [1]=>
  int(22)
  [2]=>
  int(33)
  [3]=>
  int(44)
}
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.map">
      <title><literal>Map</literal></title>
      <informalexample>
        <programlisting role="php" location="hack.collections25.php" />
        &example.outputs;
        <screen>
<![CDATA[
object(Map)#1 (3) {
  ["a"]=>
  int(11)
  ["b"]=>
  int(22)
  ["c"]=>
  int(33)
}
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.buildingconcretecollection">
      <title>Building a Concrete Collection</title>
      <informalexample>
        <programlisting role="php" location="hack.collections26.php" />
        &example.outputs;
        <screen>
<![CDATA[
object(Vector)#1 (3) {
  [0]=>
  int(11)
  [1]=>
  int(22)
  [2]=>
  int(33)
}
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.generalinterface">
      <title>General Collection Interfaces</title>
      <informalexample>
        <programlisting role="php" location="hack.collections27.php" />
        &example.outputs;
        <screen>
<![CDATA[
object(HH\Vector)#2 (2) {
  [0]=>
  int(2)
  [1]=>
  int(3)
}
]]>
        </screen>
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.generators">
      <title>Generators</title>
      <informalexample>
        <programlisting role="php" location="hack.collections28.php" />
      </informalexample>
    </sect2>
    <sect2 xml:id="hack.collections.examples.indexish">
      <title>Converting to <literal>Indexish</literal></title>
      <para>
        <emphasis>Real-world, existing code</emphasis>
        <informalexample>
          <programlisting role="php" location="hack.collections29.php" />
        </informalexample>
      </para>
      <para>
        <emphasis>Possible <literal>Indexish</literal> modification #1</emphasis>
        <informalexample>
          <programlisting role="php" location="hack.collections30.php" />
        </informalexample>
      </para>
      <para>
        <emphasis>Possible <literal>Indexish</literal> modification #2</emphasis>
        <informalexample>
          <programlisting role="php" location="hack.collections31.php" />
        </informalexample>
      </para>
      <para>
        <emphasis>Test Code</emphasis>
        <informalexample>
          <programlisting role="php" location="hack.collections32.php" />
          &example.outputs;
          <screen>
<![CDATA[
array(4) {
  [0]=>
  int(7)
  [1]=>
  int(8)
  [2]=>
  int(9)
  [3]=>
  int(10)
}
array(4) {
  [0]=>
  int(7)
  [1]=>
  int(8)
  [2]=>
  int(9)
  [3]=>
  int(10)
}
object(Map)#1 (4) {
  [0]=>
  int(7)
  [1]=>
  int(8)
  [2]=>
  int(9)
  [3]=>
  int(10)
}
array(4) {
  [0]=>
  int(7)
  [1]=>
  int(8)
  [2]=>
  int(9)
  [3]=>
  int(10)
}
array(4) {
  [0]=>
  int(7)
  [1]=>
  int(8)
  [2]=>
  int(9)
  [3]=>
  int(10)
}
object(Map)#3 (4) {
  [0]=>
  int(7)
  [1]=>
  int(8)
  [2]=>
  int(9)
  [3]=>
  int(10)
}
]]>
          </screen>
        </informalexample>
      </para>
    </sect2>
  </sect1>

  <sect1 xml:id="hack.collections.limitations">
    <title>Limitations</title>
    <orderedlist>
      <listitem>
        <para>
          Collections do not support taking elements by reference for performance and type safety reasons.
        </para>
      </listitem>
      <listitem>
        <para>
          Collections do not support dynamic properties.
        </para>
      </listitem>
      <listitem>
        <para>
          &lt;, &lt;=, &gt;, and &gt;= are not currently supported for collections (these will raise an error at runtime), though these will likely be supported in the future.
        </para>
      </listitem>
    </orderedlist>
  </sect1>

  <sect1 xml:id="hack.collections.futurework">
    <title>Future work on collections</title>
    <para>
      For this first version of Hack collections, there are features
      that did not make the cut. 
      <orderedlist>
        <listitem>
          <para>
            Better support for iterators:
          </para>
          <itemizedlist>
            <listitem>
              <para>
                Bidirectional iterators (ability to move both forward and backward) </para>
            </listitem>
            <listitem>
              <para>
                Ability to quickly get an iterator pointing to the last element </para>
            </listitem>
            <listitem>
              <para>
                <literal>find()</literal> method for quickly getting an iterator for a given key (<literal>Map</literal>) or for a given value (<literal>Set</literal>)
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>findKey()</literal> method for quickly getting an iterator for a given index (<literal>Vector</literal>)
              </para>
            </listitem>
            <listitem>
              <para>
                Swapping items via iterators
              </para>
            </listitem>
            <listitem>
              <para>
                Comparing two iterators for equality (i.e., check if they point to the same element in the same collection)
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            Supporting object keys for <literal>Map</literal>, and supporting object values for <literal>Set</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            Methods for finding or removing elements by value in O(n) time.
          </para>
        </listitem>
        <listitem>
          <para>
            Generic support for erasing multiple items cleanly and efficiently (ex. an idiom for erasing elements during iteration)
          </para>
        </listitem>
        <listitem>
          <para>
            Other possible data structure types such as <literal>LinkedList</literal>, <literal>SortedMap</literal>, <literal>MultiSet</literal>, <literal>MultiMap</literal>, etc..
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>insert()</literal> method for quickly inserting an element at an arbitrary position in an order-preserving collection (this would be useful if we later support <literal>LinkedList</literal>).
          </para>
        </listitem>
      </orderedlist>
    </para>
  </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
