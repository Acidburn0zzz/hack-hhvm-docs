<?xml version="1.0" encoding="utf-8"?>
<chapter xml:id="hack.traits">
  <title>Traits</title>
  <para>
    Traits are &quot;interfaces with implementation&quot;, that, at runtime, are &quot;copied and pasted&quot; into the class that uses the trait. The Hack type checker treats traits differently than
    HHVM. Hack treats traits as a stand-alone entity during the type checking process. In other words, it ensures type consistency within the trait (i.e., as a black box, so to speak), but does not &quot;copy and paste&quot; the code into all of the classes that use the trait and check for type consistency there. The reason this is done comes down to performance. It would be quite difficult to incrementally check Hack-enabled code in any performant way when trait code had to be inserted into a bunch of classes during the process.
  </para>
  <para>
    Hack will correctly type check all the code within a trait:
    <informalexample>
      <programlisting role="php" location="hack.traits1.php" />
      &example.outputs;
      <screen>
<![CDATA[
File "traits.php", line 12, characters 12-18:
Invalid return type
File "traits.php", line 11, characters 46-51:
This is a string
File "traits.php", line 11, characters 33-36:
It is incompatible with a bool
]]>
      </screen>
    </informalexample>
  </para>
  <para>
    Hack will also throw an error on the following code, although the code runs perfectly fine.
    <informalexample>
      <programlisting role="php" location="hack.traits2.php" />
      &example.outputs;
      <screen>
<![CDATA[
File "traits.php", line 6, characters 19-24:
The method bar is undefined in an object of type TTT
]]>
      </screen>
      <screen>
<![CDATA[
int(5)
]]>
      </screen>
    </informalexample>
  </para>
  <para>
    Using <literal>$this</literal> in a trait on a method defined in the class where the trait will be used is not supported in Hack (remember traits are basically standalone entities to Hack). In order to remedy the above limitation from the Hack type checker, <literal>// UNSAFE</literal> could be used within <literal>foo()</literal>, or the file could be put in Hack's <literal>// decl</literal> mode. However, a better option is to use an <emphasis>abstract method</emphasis> within the trait. Traits support the use of abstract methods in order to impose requirements upon the class(es) where the trait will be used.
    <informalexample>
      <programlisting role="php" location="hack.traits3.php" />
      &example.outputs;
      <screen>
<![CDATA[
No errors!
]]>
      </screen>
	<screen>
<![CDATA[
int(5)
]]>
      </screen>
    </informalexample>
  </para>
  <para>
    It is important to note that HHVM allows traits to implement interfaces (something not currently available in PHP), and Hack does support that feature with traits. The following example shows a trait implementing an interface.
    <informalexample>
      <programlisting role="php" location="hack.traits4.php" />
      &example.outputs;
      <screen>
<![CDATA[
No errors!
]]>
      </screen>
      <screen>
<![CDATA[
int(5)
]]>
      </screen>
    </informalexample>
  </para>
  <para>
    Notice how, in <literal>Baz</literal>, <literal>$this</literal> is being used to access methods that were defined in the trait <literal>Foo</literal>. Remember, Hack allows using <literal>$this</literal> on such methods since traits are basically checked as a standalone entity; in this case, the trait has type consistency.
  </para>

  <sect1 xml:id="hack.traits.requirements">
    <title>Trait Requirements</title>
	  <para>
	    The Hack type checker is effective because it is able to take annotated facts sprinkled across a codebase (function entry and exit points, class definitions, etc), reconcile them, and detect any mismatches. Traits are a sizeable wrench in the works. The nature of traits in PHP is to "declare a bunch of stuff to be thrown into another scope at a later time, then check if it works at runtime"; the Hack type checker is only happy if it can take a piece of code and statically verify it independently of its usage sites. A syntactic way of having traits state that they only apply inside a particular type hierarchy allows their declarations to be both more explicit and more amenable to static analysis.
	    <informalexample>
	      <programlisting role="php" location="hack.traits5.php" />
	    </informalexample>
	  </para>
	  <para>
	    When enforcing trait requirements, all <literal>T</literal> cares about is that <literal>X</literal> instanceof <literal>C</literal> is true and <literal>X</literal> instanceof <literal>I</literal> is true for any using class <literal>X</literal>. It doesn't care about how exactly compliance with <literal>X</literal>'s declared interfaces is achieved, or how many layers of inheritance there might be between <literal>X</literal> and <literal>C</literal>.
	    <informalexample>
	      <programlisting role="php" location="hack.traits6.php" />
	    </informalexample>
	  </para>
	  <para>
	    So what is the rationale for trait requirements? While traits can theoretically be used for aspect oriented programming to add functionality to a class that is entirely orthogonal to the rest of the class definition, in practice it seems that a major, if not the dominant, use case for traits is to provide an implementation of functionality that applies only within the context of a particular class hierarchy. For example, if there are 50 subclasses of <literal>X</literal>, and <literal>X::foo()</literal> has 3 different recommended implementations, the 3 traits that make those implementations possible are meaningless outside of the class hierarchy and over time may start to justifiably use the functionality of <literal>X</literal>.
	  </para>
	  <para>
	    Trait requirement declarations serve to tie traits to class hierarchies and move the issues of assumptions about the using class from being discoverable only at run time to being easily discoverable in static analysis. In the example above, <literal>T</literal>'s trait requirements indicate that <literal>I</literal> is something that classes using <literal>T</literal> are required to implement.
	  </para>
	  <para>
	    For the purposes of the Hack type checker, trait requirements now mean that any functions inside <literal>T</literal> above now know that <literal>$this</literal> instanceof <literal>C</literal> and <literal>$this</literal> instanceof <literal>I</literal> are true, and duplicating the implementations of <literal>C</literal> and <literal>I</literal> using redundant abstract function declarations is no longer necessary.
	  </para>
  </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
